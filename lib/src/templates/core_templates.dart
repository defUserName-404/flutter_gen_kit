// core_templates.dart

const String mainDartTemplate = r'''
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:provider/provider.dart';

import 'core/app.dart';
import 'core/config/app_config.dart';
import 'core/router/app_router.dart';
import 'core/service_locator.dart';
import 'generated/l10n.dart'; // Generated by `flutter gen-l10n`

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Load app configuration
  await AppConfig.load();

  // Setup Dependency Injection
  await ServiceLocator.setup();

  runApp(
    MultiProvider(
      providers: AppProviders.providers,
      child: const MainApp(),
    ),
  );
}

class MainApp extends StatelessWidget {
  const MainApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerConfig: AppRouter.router,
      title: AppConfig.appName,
      debugShowCheckedModeBanner: false,
      theme: ThemeData.light(), // Placeholder, will use actual theme
      darkTheme: ThemeData.dark(), // Placeholder, will use actual theme
      themeMode: ThemeMode.system, // Placeholder, will be managed by a ThemeProvider

      // Localization delegates
      localizationsDelegates: const [
        S.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: S.delegate.supportedLocales,
    );
  }
}
''';

const String coreAppTemplate = r'''
// Not strictly needed with MaterialApp.router, but kept for consistency
// and potential future complex app structures.
// For now, MainApp in main.dart is sufficient.
// This file can be removed if a simpler App structure is preferred.
''';

const String appProvidersTemplate = r'''
import 'package:provider/provider.dart';
import 'package:provider/single_child_widget.dart';

import '../core/service_locator.dart';
import '../features/sample_feature/presentation/viewmodels/sample_viewmodel.dart'; // Example

class AppProviders {
  static List<SingleChildWidget> providers = [
    // Register global providers here
    ChangeNotifierProvider(
      create: (_) => ServiceLocator.instance<SampleViewModel>(), // Example ViewModel
    ),
    // ... other providers
  ];
}
''';

const String serviceLocatorTemplate = r'''
import 'package:get_it/get_it.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:internet_connection_checker_plus/internet_connection_checker_plus.dart';
import 'package:dio/dio.dart';

import '../core/logger/app_logger.dart';
import '../core/network/api_client.dart';
import '../core/network/network_info.dart';

import '../features/sample_feature/data/datasources/sample_local_datasource.dart';
import '../features/sample_feature/data/datasources/sample_remote_datasource.dart';
import '../features/sample_feature/data/repositories/sample_repository_impl.dart';
import '../features/sample_feature/domain/repositories/sample_repository.dart';
import '../features/sample_feature/domain/usecases/get_sample_data.dart';
import '../features/sample_feature/presentation/viewmodels/sample_viewmodel.dart';

class ServiceLocator {
  ServiceLocator._();

  static final GetIt _sl = GetIt.instance;

  static GetIt get instance => _sl;

  static Future<void> setup() async {
    // External dependencies
    final sharedPreferences = await SharedPreferences.getInstance();
    _sl.registerLazySingleton<SharedPreferences>(() => sharedPreferences);
    _sl.registerLazySingleton<InternetConnectionCheckerPlus>(() => InternetConnectionCheckerPlus());
    _sl.registerLazySingleton<Dio>(() => Dio());

    // Core services
    _sl.registerLazySingleton<AppLogger>(() => AppLogger());
    _sl.registerLazySingleton<NetworkInfo>(() => NetworkInfoImpl(_sl()));
    _sl.registerLazySingleton<ApiClient>(() => ApiClient(_sl(), _sl()));
    
    // Feature-specific dependencies
    _setupSampleFeature();
  }

  static void _setupSampleFeature() {
    // Data sources
    _sl.registerLazySingleton<SampleLocalDataSource>(() => SampleLocalDataSourceImpl(sharedPreferences: _sl()));
    _sl.registerLazySingleton<SampleRemoteDataSource>(() => SampleRemoteDataSourceImpl(apiClient: _sl()));

    // Repositories
    _sl.registerLazySingleton<SampleRepository>(
      () => SampleRepositoryImpl(
        localDataSource: _sl(),
        remoteDataSource: _sl(),
      ),
    );

    // Use cases
    _sl.registerFactory(() => GetSampleData(repository: _sl()));

    // ViewModels
    _sl.registerFactory(() => SampleViewModel(getSampleData: _sl()));
  }
}
''';

const String appConfigTemplate = r'''
import 'package:flutter/services.dart' show rootBundle;
import 'dart:convert';

class AppConfig {
  static late Map<String, dynamic> _config;

  static String get appName => _config['appName'] as String;
  static String get baseUrl => _config['baseUrl'] as String;
  // Add other configurations as needed

  static Future<void> load() async {
    final configString = await rootBundle.loadString('assets/config/app_config.json');
    _config = json.decode(configString) as Map<String, dynamic>;
  }
}
''';

const String appRouterTemplate = r'''
import 'package:go_router/go_router.dart';
import 'package:flutter/material.dart';

import '../../features/sample_feature/presentation/screens/sample_screen.dart'; // Example

class AppRouter {
  static final GoRouter router = GoRouter(
    routes: <RouteBase>[
      GoRoute(
        path: '/',
        builder: (BuildContext context, GoRouterState state) {
          return const SampleScreen(); // Initial screen
        },
      ),
      // Add more routes here for features
      GoRoute(
        path: '/sample',
        builder: (BuildContext context, GoRouterState state) {
          return const SampleScreen();
        },
      ),
    ],
    // Redirect logic, error handling etc.
    // errorBuilder: (context, state) => const ErrorScreen(), // You would define an ErrorScreen
  );
}
''';

const String appThemeTemplate = r'''
import 'package:flutter/material.dart';

import 'app_colors.dart';
import 'app_typography.dart';

class AppTheme {
  static ThemeData lightTheme = ThemeData(
    primaryColor: AppColors.primary,
    colorScheme: ColorScheme.fromSeed(seedColor: AppColors.primary),
    scaffoldBackgroundColor: AppColors.backgroundLight,
    textTheme: AppTypography.lightTextTheme,
    appBarTheme: const AppBarTheme(
      backgroundColor: AppColors.primary,
      foregroundColor: AppColors.onPrimary,
      elevation: 0,
    ),
    // Add more light theme properties
  );

  static ThemeData darkTheme = ThemeData(
    primaryColor: AppColors.primaryDark,
    colorScheme: ColorScheme.fromSeed(seedColor: AppColors.primaryDark),
    scaffoldBackgroundColor: AppColors.backgroundDark,
    textTheme: AppTypography.darkTextTheme,
    appBarTheme: const AppBarTheme(
      backgroundColor: AppColors.primaryDark,
      foregroundColor: AppColors.onPrimaryDark,
      elevation: 0,
    ),
    // Add more dark theme properties
  );
}
''';

const String appColorsTemplate = r'''
import 'package:flutter/material.dart';

class AppColors {
  // Light Theme Colors
  static const Color primary = Color(0xFF6200EE);
  static const Color onPrimary = Colors.white;
  static const Color secondary = Color(0xFF03DAC6);
  static const Color onSecondary = Colors.black;
  static const Color backgroundLight = Color(0xFFF0F2F5);
  static const Color onBackgroundLight = Colors.black;
  static const Color surfaceLight = Colors.white;
  static const Color onSurfaceLight = Colors.black;
  static const Color error = Color(0xFFB00020);
  static const Color onError = Colors.white;

  // Dark Theme Colors
  static const Color primaryDark = Color(0xFFBB86FC);
  static const Color onPrimaryDark = Colors.black;
  static const Color secondaryDark = Color(0xFF03DAC6);
  static const Color onSecondaryDark = Colors.black;
  static const Color backgroundDark = Color(0xFF121212);
  static const Color onBackgroundDark = Colors.white;
  static const Color surfaceDark = Color(0xFF1E1E1E);
  static const Color onSurfaceDark = Colors.white;
  static const Color errorDark = Color(0xFFCF6679);
  static const Color onErrorDark = Colors.black;
}
''';

const String appTypographyTemplate = r'''
import 'package:flutter/material.dart';

class AppTypography {
  static TextTheme lightTextTheme = const TextTheme(
    displayLarge: TextStyle(fontSize: 57.0, fontWeight: FontWeight.normal),
    displayMedium: TextStyle(fontSize: 45.0, fontWeight: FontWeight.normal),
    displaySmall: TextStyle(fontSize: 36.0, fontWeight: FontWeight.normal),
    headlineLarge: TextStyle(fontSize: 32.0, fontWeight: FontWeight.normal),
    headlineMedium: TextStyle(fontSize: 28.0, fontWeight: FontWeight.normal),
    headlineSmall: TextStyle(fontSize: 24.0, fontWeight: FontWeight.normal),
    titleLarge: TextStyle(fontSize: 22.0, fontWeight: FontWeight.normal),
    titleMedium: TextStyle(fontSize: 16.0, fontWeight: FontWeight.w500),
    titleSmall: TextStyle(fontSize: 14.0, fontWeight: FontWeight.w500),
    bodyLarge: TextStyle(fontSize: 16.0, fontWeight: FontWeight.normal),
    bodyMedium: TextStyle(fontSize: 14.0, fontWeight: FontWeight.normal),
    bodySmall: TextStyle(fontSize: 12.0, fontWeight: FontWeight.normal),
    labelLarge: TextStyle(fontSize: 14.0, fontWeight: FontWeight.w500),
    labelMedium: TextStyle(fontSize: 12.0, fontWeight: FontWeight.w500),
    labelSmall: TextStyle(fontSize: 11.0, fontWeight: FontWeight.w500),
  );

  static TextTheme darkTextTheme = lightTextTheme; // Often same or slightly adjusted
}
''';

const String apiClientTemplate = r'''
import 'package:dio/dio.dart';

import '../../common/data/exceptions/app_exceptions.dart';
import '../logger/app_logger.dart';

class ApiClient {
  final Dio dio;
  final AppLogger logger;

  ApiClient(this.dio, this.logger) {
    dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          logger.d('Request: ${options.method} ${options.uri}');
          logger.d('Headers: ${options.headers}');
          if (options.data != null) {
            logger.d('Data: ${options.data}');
          }
          return handler.next(options);
        },
        onResponse: (response, handler) {
          logger.d('Response: ${response.statusCode} ${response.requestOptions.uri}');
          logger.d('Data: ${response.data}');
          return handler.next(response);
        },
        onError: (DioException e, handler) {
          logger.e('Error: ${e.response?.statusCode} ${e.requestOptions.uri}');
          logger.e('Error data: ${e.response?.data}');
          return handler.next(e); // Pass the error along
        },
      ),
    );
  }

  Future<Response> get(String path, {Map<String, dynamic>? queryParameters}) async {
    try {
      final response = await dio.get(path, queryParameters: queryParameters);
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<Response> post(String path, {dynamic data}) async {
    try {
      final response = await dio.post(path, data: data);
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<Response> put(String path, {dynamic data}) async {
    try {
      final response = await dio.put(path, data: data);
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<Response> delete(String path, {dynamic data}) async {
    try {
      final response = await dio.delete(path, data: data);
      return response;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  AppException _handleDioError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return ConnectionException('Connection timed out');
      case DioExceptionType.badResponse:
        final statusCode = error.response?.statusCode;
        final message = error.response?.data['message'] as String? ?? 'An error occurred';
        if (statusCode == 400) {
          return BadRequestException(message);
        } else if (statusCode == 401) {
          return UnauthorizedException(message);
        } else if (statusCode == 403) {
          return ForbiddenException(message);
        } else if (statusCode == 404) {
          return NotFoundException(message);
        } else if (statusCode == 500) {
          return ServerException(message);
        }
        return ApiException(message);
      case DioExceptionType.cancel:
        return RequestCancelledException('Request cancelled');
      case DioExceptionType.unknown:
      default:
        return ConnectionException('No internet connection');
    }
  }
}
''';

const String appLoggerTemplate = r'''
import 'package:logger/logger.dart';

class AppLogger {
  final Logger _logger;

  AppLogger() : _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 2, // number of method calls to be displayed
      errorMethodCount: 8, // number of method calls if stacktrace is provided
      lineLength: 120, // width of the output
      colors: true, // Colorful log messages
      printEmojis: true, // Print an emoji for each log message
      printTime: false, // Should each log message contain a timestamp
    ),
  );

  void d(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.d(message, error: error, stackTrace: stackTrace);
  }

  void i(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.i(message, error: error, stackTrace: stackTrace);
  }

  void w(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.w(message, error: error, stackTrace: stackTrace);
  }

  void e(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.e(message, error: error, stackTrace: stackTrace);
  }

  void f(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.f(message, error: error, stackTrace: stackTrace);
  }

  void v(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.v(message, error: error, stackTrace: stackTrace);
  }
}
''';

const String appExceptionsTemplate = r'''
abstract class AppException implements Exception {
  final String message;
  final String? prefix;

  AppException(this.message, [this.prefix]);

  @override
  String toString() {
    return '$prefix: $message';
  }
}

class ApiException extends AppException {
  ApiException(String message) : super(message, 'API Error');
}

class ConnectionException extends AppException {
  ConnectionException(String message) : super(message, 'Connection Error');
}

class BadRequestException extends AppException {
  BadRequestException(String message) : super(message, 'Bad Request');
}

class UnauthorizedException extends AppException {
  UnauthorizedException(String message) : super(message, 'Unauthorized');
}

class ForbiddenException extends AppException {
  ForbiddenException(String message) : super(message, 'Forbidden');
}

class NotFoundException extends AppException {
  NotFoundException(String message) : super(message, 'Not Found');
}

class ServerException extends AppException {
  ServerException(String message) : super(message, 'Server Error');
}

class RequestCancelledException extends AppException {
  RequestCancelledException(String message) : super(message, 'Request Cancelled');
}
''';

const String baseViewModelTemplate = r'''
import 'package:flutter/material.dart';

// Base ViewModel for common logic and ChangeNotifier
abstract class BaseViewModel extends ChangeNotifier {
  bool _isLoading = false;
  String? _errorMessage;

  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;

  void setLoading(bool value) {
    _isLoading = value;
    notifyListeners();
  }

  void setErrorMessage(String? message) {
    _errorMessage = message;
    notifyListeners();
  }

  // Example for handling asynchronous operations
  Future<void> runCatching(Future<void> Function() block) async {
    setLoading(true);
    setErrorMessage(null);
    try {
      await block();
    } catch (e) {
      setErrorMessage(e.toString());
      // Optionally log error here
    } finally {
      setLoading(false);
    }
  }
}
''';

const String commonConstantsTemplate = r'''
// You can define common constants here
class AppConstants {
  static const String appName = 'Generated App';
  static const String defaultLocale = 'en';
}
''';

const String commonLoadingIndicatorTemplate = r'''
import 'package:flutter/material.dart';

class LoadingIndicator extends StatelessWidget {
  const LoadingIndicator({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: CircularProgressIndicator(),
    );
  }
}
''';

const String appLocalizationTemplate = r'''
import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';

// This is a placeholder. Real localization would use the generated `S` class.
class AppLocalizations {
  static String of(BuildContext context) {
    return Intl.message(
      'Hello from generated app!',
      name: 'helloMessage',
      desc: 'A message for the user.',
    );
  }

  // Example using the generated S class (after `flutter gen-l10n` is run)
  // static String helloMessage(BuildContext context) {
  //   return S.of(context).helloMessage;
  // }
}
''';

const String l10nEnArbTemplate = r'''
{
    "@@locale": "en",
    "helloMessage": "Hello from generated app!"
}
''';

const String networkInfoTemplate = r'''
import 'package:internet_connection_checker_plus/internet_connection_checker_plus.dart';

abstract class NetworkInfo {
  Future<bool> get isConnected;
}

class NetworkInfoImpl implements NetworkInfo {
  final InternetConnectionCheckerPlus connectionChecker;

  NetworkInfoImpl(this.connectionChecker);

  @override
  Future<bool> get isConnected => connectionChecker.hasConnection;
}
''';
